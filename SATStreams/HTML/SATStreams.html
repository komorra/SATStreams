<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Real-time Metrics Dashboard</title>

    <!-- Chart.js CDN -->
    <script src="https://cdn.jsdelivr.net/npm/chart.js@4.4.1/dist/chart.umd.min.js"></script>

    <style>
        body {
            font-family: Arial, sans-serif;
            margin: 0;
            padding: 1rem;
            background: #f5f5f5;
        }

        h1 {
            text-align: center;
            margin-bottom: 1rem;
        }

        /* Simple responsive grid */
        #charts {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(320px, 1fr));
            gap: 24px;
        }

        .chart-container {
            background: #fff;
            border-radius: 12px;
            padding: 16px;
            box-shadow: 0 2px 6px rgba(0, 0, 0, 0.15);
        }

        canvas {
            width: 100% !important;
            max-height: 260px;
        }
    </style>
</head>
<body>
    <h1>Real-time Metrics Dashboard</h1>
    <div id="charts"></div>

    <script>
      // List of metric keys expected from the backend JSON
      const metricKeys = [
        "LowestStreamSize",
        "HighestStreamSize",
        "StreamCount",
        "SolvedVars",
        "TotalVars",
        "Deletions",
        "Additions",
        "DeletionsPerMinute",
        "AdditionsPerMinute",
        "SolvedVarsPerMinute",
        "Progress",
      ];

      const maxPoints = 60; // Keep last 60 seconds of data
      const charts = {}; // Dictionary to hold Chart.js instances

      /**
       * Creates a line chart and returns the Chart instance.
       * @param {HTMLCanvasElement} canvas
       * @param {string} metric
       */
      function createChart(canvas, metric) {
        return new Chart(canvas.getContext("2d"), {
          type: "line",
          data: {
            labels: [],
            datasets: [
              {
                label: metric,
                data: [],
                fill: false,
              },
            ],
          },
          options: {
            responsive: true,
            maintainAspectRatio: false,
            animation: false,
            scales: {
              x: {
                display: true,
                ticks: {
                  autoSkip: true,
                  maxTicksLimit: 6,
                },
              },
              y: {
                beginAtZero: true,
              },
            },
            plugins: {
              legend: {
                display: false,
              },
            },
          },
        });
      }

      // Dynamically build canvas elements and charts for each metric
      (function init() {
        const chartsContainer = document.getElementById("charts");
        metricKeys.forEach((key) => {
          const container = document.createElement("div");
          container.className = "chart-container";

          const title = document.createElement("h3");
          title.textContent = key;
          title.style.margin = "0 0 8px 0";
          container.appendChild(title);

          const canvas = document.createElement("canvas");
          container.appendChild(canvas);
          chartsContainer.appendChild(container);

          charts[key] = createChart(canvas, key);
        });
      })();

      /**
       * Fetches metrics from the backend and updates all charts.
       */
      async function fetchMetrics() {
        try {
          const response = await fetch("http://localhost:8888");
          if (!response.ok) throw new Error("Network response was not ok");
          const data = await response.json();

          const timestamp = new Date().toLocaleTimeString();

          metricKeys.forEach((key) => {
            const chart = charts[key];
            if (!chart) return;

            chart.data.labels.push(timestamp);
            chart.data.datasets[0].data.push(data[key]);

            // Trim old points to keep the data window fixed
            if (chart.data.labels.length > maxPoints) {
              chart.data.labels.shift();
              chart.data.datasets[0].data.shift();
            }

            chart.update("none"); // Update without animation for smoother real-time feel
          });
        } catch (error) {
          console.error("Error fetching metrics:", error);
        }
      }

      // Kick off periodic fetching every second
      setInterval(fetchMetrics, 1000);
      // Initial call so we don't wait a whole second to populate
      fetchMetrics();
    </script>
</body>
</html>
